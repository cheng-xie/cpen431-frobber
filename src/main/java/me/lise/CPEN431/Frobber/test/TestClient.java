package me.lise.CPEN431.Frobber.test;

import ca.NetSysLab.ProtocolBuffers.Message.Msg;
import ca.NetSysLab.ProtocolBuffers.KeyValueRequest.KVRequest;
import ca.NetSysLab.ProtocolBuffers.KeyValueResponse.KVResponse;
import me.lise.CPEN431.Frobber.util.MessageUtil;

import com.google.protobuf.*;

import java.io.IOException;
import java.net.*;
import java.nio.*;
import java.util.*;

/**
 * Test client that opens a socket that can be used to send and receive messages to a specified host.
 */
public class TestClient {
    private static final int MAX_TRIES = 4;  // initial try + 3 retries
    private static final int INITIAL_TIMEOUT = 100;  // ms
    private static final int HEADER_LENGTH = 16;  // bytes

    /** The largest possible response is 10000 B (max value size) + header + 5 ints + some extra Bs to be safe */
    private static final int MAX_PAYLOAD = 10100;

    private DatagramSocket socket;
    private InetAddress hostAddress;
    private int hostPort;

    /**
     * Helper function to generate a unique ID.
     * @return A byte array containing the generated ID.
     * @throws UnknownHostException In case of an error getting the local host address.
     */
    private byte[] getID() throws UnknownHostException {
        byte[] result = ByteBuffer.allocate(HEADER_LENGTH)
                .putInt(2, socket.getLocalPort())
                .putLong(8, System.nanoTime())
                .array();

        // Copy in the IP address
        byte[] ip = InetAddress.getLocalHost().getAddress();
        for (int i = 0; i < 4; i++) {
            result[i] = ip[i];
        }

        // Add two randomly generated bytes
        Random rand = new Random();
        result[6] = (byte) rand.nextInt(0xff);
        result[7] = (byte) rand.nextInt(0xff);

        return result;
    }

    /**
     * Shared code to listen for a reply packet after sending a request.
     * @param timeout How long to wait.
     * @return The packet.
     * @throws IOException
     */
    private DatagramPacket getResponse(byte[] buf, int timeout) throws IOException {
        DatagramPacket packet = new DatagramPacket(buf, buf.length);
        socket.setSoTimeout(timeout);
        socket.receive(packet);
        return packet;
    }

    /**
     * Create a client to send messages.
     * @throws SocketException if socket creation failed.
     */
    public TestClient(InetAddress host, int port) throws SocketException {
        this.socket = new DatagramSocket();
        this.hostAddress = host;
        this.hostPort = port;
    }

    /**
     * Generic method to send a {@code KVRequest} and get the response.
     * @param request The request to send.
     * @return The response as a {@code KVResponse}. If no response was received, return null.
     */
    public KVResponse sendReceive(KVRequest request) throws IOException {
        // Wrap the payload
        Msg message = MessageUtil.makeMessage(getID(), request.toByteArray());

        int timeout = INITIAL_TIMEOUT;
        for (int i = 0; i < MAX_TRIES; i++) {
            // Convert to byte array and send
            byte[] messageBytes = message.toByteArray();
            DatagramPacket packet = new DatagramPacket(messageBytes, messageBytes.length, hostAddress, hostPort);
            socket.send(packet);

            // Wait for a reply
            byte[] buf = new byte[MAX_PAYLOAD];
            try {
                packet = new DatagramPacket(buf, buf.length);
                socket.setSoTimeout(timeout);
                socket.receive(packet);
            } catch (SocketTimeoutException e) {
                timeout *= 2;
                continue;
            }

            // Parse packet and verify its checksum and header
            Msg response;
            try {
                response = Msg.parseFrom(Arrays.copyOf(packet.getData(), packet.getLength()));
            } catch (InvalidProtocolBufferException e) {
                // There was a parse error of some sort. Maybe this was due to corruption, so let's try again.
                continue;
            }

            if (!MessageUtil.validateChecksum(response) || !MessageUtil.validateMessageID(message, response)) {
                continue;
            }

            // Extract the response and return it
            return KVResponse.parseFrom(response.getPayload());
        }

        // If this is reached, all the requests either timed out or got a garbage response
        return null;
    }

    public KVResponse sendPut(ByteString key, ByteString value, int version) throws IOException {
        KVRequest.Builder request = KVRequest.newBuilder().setCommand(Command.PUT).setKey(key).setValue(value);
        if (version != 0) {
            request.setVersion(version);
        }
        return sendReceive(request.build());
    }

    public KVResponse sendPut(ByteString key, ByteString value) throws IOException {
        return sendPut(key, value, 0);
    }

    public KVResponse sendGet(ByteString key) throws IOException {
        return sendReceive(KVRequest.newBuilder().setCommand(Command.GET).setKey(key).build());
    }

    public KVResponse sendRemove(ByteString key) throws IOException {
        return sendReceive(KVRequest.newBuilder().setCommand(Command.REMOVE).setKey(key).build());
    }

    public KVResponse sendWipeout() throws IOException {
        return sendReceive(KVRequest.newBuilder().setCommand(Command.WIPEOUT).build());
    }

    public KVResponse sendIsAlive() throws IOException {
        return sendReceive(KVRequest.newBuilder().setCommand(Command.IS_ALIVE).build());
    }

    public KVResponse sendGetPid() throws IOException {
        return sendReceive(KVRequest.newBuilder().setCommand(Command.GET_PID).build());
    }

    public KVResponse sendGetMembershipCount() throws IOException {
        return sendReceive(KVRequest.newBuilder().setCommand(Command.GET_MEMBERSHIP_COUNT).build());
    }

    public KVResponse sendShutdown() throws IOException {
        return sendReceive(KVRequest.newBuilder().setCommand(Command.SHUTDOWN).build());
    }

    public void close() {
        socket.close();
    }
}

class Command {
    static int PUT = 0x1;
    static int GET = 0x2;
    static int REMOVE = 0x3;
    static int SHUTDOWN = 0x4;
    static int WIPEOUT = 0x5;
    static int IS_ALIVE = 0x6;
    static int GET_PID = 0x7;
    static int GET_MEMBERSHIP_COUNT = 0x8;
}

class ErrCode {
    static int OKAY = 0x0;
    static int NO_KEY = 0x1;
    static int NO_SPACE = 0x2;
    static int OVERLOAD = 0x3;
    static int FAILURE = 0x4;
    static int BAD_COMMAND = 0x5;
    static int BAD_KEY = 0x6;
    static int BAD_VALUE = 0x7;
}
